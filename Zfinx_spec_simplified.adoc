
[[Title]]
= "Zfinx" Standard Extension for Sharing Integer and Floating Point Registers v0.41
Version 0.41
:doctype: book
:encoding: utf-8
:lang: en
:toc: left
:toclevels: 4
:numbered:
:xrefstyle: short
:le: &#8804;
:rarr: &#8658;

== Overview

If `Zfinx` is implemented then _all_ extensions which access `F` state are modified to access `X` register state instead. Therefore floating point register state is not implemented, as a result part of the standard extensions ISA becomes redundant and so only a subset is implemented.

== Zfinx configurations

All `Zfinx` configurations require the width of the floating point state to be specified by the widest floating point standard extension to be implemented. Therefore in the configuration string, instead of the width of the `F` registers being specified by the `F/D/Q` standard extensions, the equivalent `Zfinx` version is used instead, `ZFinx/ZDinx/ZQinx`. Any additional floating point extensions can be specified after this.

The `Zfinx` versions of `F/D/Q` have the same implication rules. Therefore because `D` implies `F`, `ZDinx` implies `ZFinx`. Other extensions using `F` registers may also be implemented such as `Zfh` or `V`. In these cases the width of the floating point state is specified first in the configuration string using `ZFinx/ZDinx/ZQinx` and the additional extension or extensions are specified afterwards. 

For example `RV32IMC_ZFinx_Zfh` supports 32-bit floating point register state mapped to the integer registers and a subset of the `F` and `Zfh` ISAs.

== Floating point CSR state

`misa.F, misa.D, misa.Q` are all hardwired to zero. 

`mstatus.fs` is hardwired to zero.

`fcsr` is implemented and behaves as expected for the standard floating point extensions.

Floating point instructions and `fcsr` accesses do _not_ trap if `mstatus.fs=0`. 

== ISA Subsets

All floating point load and store instructions, and integer to floating point moves are removed from the ISA of the standard floating point extensions. Integer versions are to be used instead.

For the F standard extension the following instructions are not implemented: `FLW, C.FLW, C.FLWSP, FSW, C.FSW, C.FSWSP, FMV.X.W, FMV.W.X`.

For the D standard extension the following instructions are not implemented: `FLD, C.FLD, C.FLDSP, FSD, C.FSD, C.FSDSP, FMV.X.D, FMV.D.X`.

== NaN-Boxing

Standard floating point extensions check that input data is NaN-boxed when issuing an instruction which is narrower than `FLEN`. If the data is not correctly NaN-boxed then the data is interpreted as a NaN. `Zfinx` cores do _not_ perform this check on the input data. 

[NOTE]

  The NaN-boxing check on inputs requires floating point load instructions to NaN-box narrow load data. Because these are removed from the ISA any narrow floating point data would need to be NaN-boxed in software which is an unnecessary burden on the software.

`Zfinx` cores do still NaN-box the output data from all narrow floating point instructions, but only up to `XLEN` bits as if `FLEN>XLEN` then register pairs are required, see <<regpairs>>.

[NOTE]

  Retaining NaN-boxing on the output minimises FPU hardware changes 

`misa.MXL` can dynamically reduce `XLEN` from the maximum implemented width. In this case the NaN-boxing is performed to the current `XLEN`, and then the result is sign-extended to the maximum implemented `XLEN`.

== Assembly syntax and code porting

Any references to `F` registers will cause assembler/disassembler errors. The encodings do not change but the syntax must refer to `x` registers.
Therefore the same encoding will disassemble as `FMADD.S f1, f2, f3, f4` or `FMADD.S x1, x2, x3, x4` depending on whether the disassembler is for a `non-Zfinx` or `Zfinx` core.

Any instructions removed from the ISA will also cause assembler/disassembler errors.

If any `Zfinx` extension is specified then the compiler will have the following #define set: `__riscv_zfinx`

[NOTE]

  Dissallowing any references to `F` registers and not having pseudo-instructions for deleted floating point loads and stores means that assembly code will need to be rewritten for `Zfinx` to avoid porting bugs.

[#regpairs]
== Register pair handling for XLEN < FLEN

For `RV32` cores implementing `ZDinx`, all D-extension instructions that are implemented will access register pairs:

. The specified register must be even, odd registers will cause an illegal instruction exception.
. Even registers will cause an even/odd pair to be accessed.
.. Accessing Xn will cause the {Xn+1, Xn} pair to be accessed, which is consistent for big and little endian modes. For example if n = 2:
... X2 is the least significant half (bits [31:0])
... X3 the most significant half (bits [63:32])
. X0 has special handling:
.. Reading {X1, X0} will read all zeros.
.. Writing {X1, X0} will discard the entire result, it will not write to X1.

The register pairs are _only_ used by the floating point arithmetic instructions. All integer loads and stores will only access up to `XLEN` bits, not `FLEN`.

== x0 register target

If a floating point instruction targets `x0` then it will still cause any side-effects from its execution but will not set the target registers.

If `XLEN<FLEN` then `x0` has special handling, see <<regpairs>>.

== Discovery

The standard discovery mechanism for `Zfinx` has yet to be defined and is currently out of scope of this specification.

== Rationale

`Zfinx` allows small embedded cores to save considerable core area and to still include floating point hardware. Small iterative floating point units can be significantly smaller than the area taken up in on-chip ROM for the floating point software library, and the performance is significantly better. Additionally the `Zfinx` core implementation is simpler then for a `non-Zfinx` core with an FPU, and the context switch time faster as there is less state to save and restore.